{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport PointerPath from './PointerPath.js';\nimport * as graphic from '../../util/graphic.js';\nimport { setStatesStylesFromModel, toggleHoverEmphasis } from '../../util/states.js';\nimport { createTextStyle, setLabelValueAnimation, animateLabelValue } from '../../label/labelStyle.js';\nimport ChartView from '../../view/Chart.js';\nimport { parsePercent, round, linearMap } from '../../util/number.js';\nimport Sausage from '../../util/shape/sausage.js';\nimport { createSymbol } from '../../util/symbol.js';\nimport ZRImage from 'zrender/lib/graphic/Image.js';\nimport { extend, isFunction, isString } from 'zrender/lib/core/util.js';\nimport { setCommonECData } from '../../util/innerStore.js';\nfunction parsePosition(seriesModel, api) {\n  var center = seriesModel.get('center');\n  var width = api.getWidth();\n  var height = api.getHeight();\n  var size = Math.min(width, height);\n  var cx = parsePercent(center[0], api.getWidth());\n  var cy = parsePercent(center[1], api.getHeight());\n  var r = parsePercent(seriesModel.get('radius'), size / 2);\n  return {\n    cx: cx,\n    cy: cy,\n    r: r\n  };\n}\nfunction formatLabel(value, labelFormatter) {\n  var label = value == null ? '' : value + '';\n  if (labelFormatter) {\n    if (isString(labelFormatter)) {\n      label = labelFormatter.replace('{value}', label);\n    } else if (isFunction(labelFormatter)) {\n      label = labelFormatter(value);\n    }\n  }\n  return label;\n}\nvar PI2 = Math.PI * 2;\nvar GaugeView = /** @class */\nfunction (_super) {\n  __extends(GaugeView, _super);\n  function GaugeView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = GaugeView.type;\n    return _this;\n  }\n  GaugeView.prototype.render = function (seriesModel, ecModel, api) {\n    this.group.removeAll();\n    var colorList = seriesModel.get(['axisLine', 'lineStyle', 'color']);\n    var posInfo = parsePosition(seriesModel, api);\n    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);\n    this._data = seriesModel.getData();\n  };\n  GaugeView.prototype.dispose = function () {};\n  GaugeView.prototype._renderMain = function (seriesModel, ecModel, api, colorList, posInfo) {\n    var group = this.group;\n    var clockwise = seriesModel.get('clockwise');\n    var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n    var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n    var axisLineModel = seriesModel.getModel('axisLine');\n    var roundCap = axisLineModel.get('roundCap');\n    var MainPath = roundCap ? Sausage : graphic.Sector;\n    var showAxis = axisLineModel.get('show');\n    var lineStyleModel = axisLineModel.getModel('lineStyle');\n    var axisLineWidth = lineStyleModel.get('width');\n    var angleRangeSpan = !((endAngle - startAngle) % PI2) && endAngle !== startAngle ? PI2 : (endAngle - startAngle) % PI2;\n    var prevEndAngle = startAngle;\n    for (var i = 0; showAxis && i < colorList.length; i++) {\n      // Clamp\n      var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n      endAngle = startAngle + angleRangeSpan * percent;\n      var sector = new MainPath({\n        shape: {\n          startAngle: prevEndAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: posInfo.r - axisLineWidth,\n          r: posInfo.r\n        },\n        silent: true\n      });\n      sector.setStyle({\n        fill: colorList[i][1]\n      });\n      sector.setStyle(lineStyleModel.getLineStyle(\n      // Because we use sector to simulate arc\n      // so the properties for stroking are useless\n      ['color', 'width']));\n      group.add(sector);\n      prevEndAngle = endAngle;\n    }\n    var getColor = function (percent) {\n      // Less than 0\n      if (percent <= 0) {\n        return colorList[0][1];\n      }\n      var i;\n      for (i = 0; i < colorList.length; i++) {\n        if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {\n          return colorList[i][1];\n        }\n      } // More than 1\n\n      return colorList[i - 1][1];\n    };\n    if (!clockwise) {\n      var tmp = startAngle;\n      startAngle = endAngle;\n      endAngle = tmp;\n    }\n    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n    this._renderTitleAndDetail(seriesModel, ecModel, api, getColor, posInfo);\n    this._renderAnchor(seriesModel, posInfo);\n    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n  };\n  GaugeView.prototype._renderTicks = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var cx = posInfo.cx;\n    var cy = posInfo.cy;\n    var r = posInfo.r;\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var splitLineModel = seriesModel.getModel('splitLine');\n    var tickModel = seriesModel.getModel('axisTick');\n    var labelModel = seriesModel.getModel('axisLabel');\n    var splitNumber = seriesModel.get('splitNumber');\n    var subSplitNumber = tickModel.get('splitNumber');\n    var splitLineLen = parsePercent(splitLineModel.get('length'), r);\n    var tickLen = parsePercent(tickModel.get('length'), r);\n    var angle = startAngle;\n    var step = (endAngle - startAngle) / splitNumber;\n    var subStep = step / subSplitNumber;\n    var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n    var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n    var splitLineDistance = splitLineModel.get('distance');\n    var unitX;\n    var unitY;\n    for (var i = 0; i <= splitNumber; i++) {\n      unitX = Math.cos(angle);\n      unitY = Math.sin(angle); // Split line\n\n      if (splitLineModel.get('show')) {\n        var distance = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;\n        var splitLine = new graphic.Line({\n          shape: {\n            x1: unitX * (r - distance) + cx,\n            y1: unitY * (r - distance) + cy,\n            x2: unitX * (r - splitLineLen - distance) + cx,\n            y2: unitY * (r - splitLineLen - distance) + cy\n          },\n          style: splitLineStyle,\n          silent: true\n        });\n        if (splitLineStyle.stroke === 'auto') {\n          splitLine.setStyle({\n            stroke: getColor(i / splitNumber)\n          });\n        }\n        group.add(splitLine);\n      } // Label\n\n      if (labelModel.get('show')) {\n        var distance = labelModel.get('distance') + splitLineDistance;\n        var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));\n        var autoColor = getColor(i / splitNumber);\n        group.add(new graphic.Text({\n          style: createTextStyle(labelModel, {\n            text: label,\n            x: unitX * (r - splitLineLen - distance) + cx,\n            y: unitY * (r - splitLineLen - distance) + cy,\n            verticalAlign: unitY < -0.8 ? 'top' : unitY > 0.8 ? 'bottom' : 'middle',\n            align: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'\n          }, {\n            inheritColor: autoColor\n          }),\n          silent: true\n        }));\n      } // Axis tick\n\n      if (tickModel.get('show') && i !== splitNumber) {\n        var distance = tickModel.get('distance');\n        distance = distance ? distance + axisLineWidth : axisLineWidth;\n        for (var j = 0; j <= subSplitNumber; j++) {\n          unitX = Math.cos(angle);\n          unitY = Math.sin(angle);\n          var tickLine = new graphic.Line({\n            shape: {\n              x1: unitX * (r - distance) + cx,\n              y1: unitY * (r - distance) + cy,\n              x2: unitX * (r - tickLen - distance) + cx,\n              y2: unitY * (r - tickLen - distance) + cy\n            },\n            silent: true,\n            style: tickLineStyle\n          });\n          if (tickLineStyle.stroke === 'auto') {\n            tickLine.setStyle({\n              stroke: getColor((i + j / subSplitNumber) / splitNumber)\n            });\n          }\n          group.add(tickLine);\n          angle += subStep;\n        }\n        angle -= subStep;\n      } else {\n        angle += step;\n      }\n    }\n  };\n  GaugeView.prototype._renderPointer = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var oldData = this._data;\n    var oldProgressData = this._progressEls;\n    var progressList = [];\n    var showPointer = seriesModel.get(['pointer', 'show']);\n    var progressModel = seriesModel.getModel('progress');\n    var showProgress = progressModel.get('show');\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var valueExtent = [minVal, maxVal];\n    var angleExtent = [startAngle, endAngle];\n    function createPointer(idx, angle) {\n      var itemModel = data.getItemModel(idx);\n      var pointerModel = itemModel.getModel('pointer');\n      var pointerWidth = parsePercent(pointerModel.get('width'), posInfo.r);\n      var pointerLength = parsePercent(pointerModel.get('length'), posInfo.r);\n      var pointerStr = seriesModel.get(['pointer', 'icon']);\n      var pointerOffset = pointerModel.get('offsetCenter');\n      var pointerOffsetX = parsePercent(pointerOffset[0], posInfo.r);\n      var pointerOffsetY = parsePercent(pointerOffset[1], posInfo.r);\n      var pointerKeepAspect = pointerModel.get('keepAspect');\n      var pointer; // not exist icon type will be set 'rect'\n\n      if (pointerStr) {\n        pointer = createSymbol(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);\n      } else {\n        pointer = new PointerPath({\n          shape: {\n            angle: -Math.PI / 2,\n            width: pointerWidth,\n            r: pointerLength,\n            x: pointerOffsetX,\n            y: pointerOffsetY\n          }\n        });\n      }\n      pointer.rotation = -(angle + Math.PI / 2);\n      pointer.x = posInfo.cx;\n      pointer.y = posInfo.cy;\n      return pointer;\n    }\n    function createProgress(idx, endAngle) {\n      var roundCap = progressModel.get('roundCap');\n      var ProgressPath = roundCap ? Sausage : graphic.Sector;\n      var isOverlap = progressModel.get('overlap');\n      var progressWidth = isOverlap ? progressModel.get('width') : axisLineWidth / data.count();\n      var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;\n      var r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;\n      var progress = new ProgressPath({\n        shape: {\n          startAngle: startAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: r0,\n          r: r\n        }\n      });\n      isOverlap && (progress.z2 = maxVal - data.get(valueDim, idx) % maxVal);\n      return progress;\n    }\n    if (showProgress || showPointer) {\n      data.diff(oldData).add(function (idx) {\n        var val = data.get(valueDim, idx);\n        if (showPointer) {\n          var pointer = createPointer(idx, startAngle); // TODO hide pointer on NaN value?\n\n          graphic.initProps(pointer, {\n            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(idx, pointer);\n        }\n        if (showProgress) {\n          var progress = createProgress(idx, startAngle);\n          var isClip = progressModel.get('clip');\n          graphic.initProps(progress, {\n            shape: {\n              endAngle: linearMap(val, valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress); // Add data index and series index for indexing the data by element\n          // Useful in tooltip\n\n          setCommonECData(seriesModel.seriesIndex, data.dataType, idx, progress);\n          progressList[idx] = progress;\n        }\n      }).update(function (newIdx, oldIdx) {\n        var val = data.get(valueDim, newIdx);\n        if (showPointer) {\n          var previousPointer = oldData.getItemGraphicEl(oldIdx);\n          var previousRotate = previousPointer ? previousPointer.rotation : startAngle;\n          var pointer = createPointer(newIdx, previousRotate);\n          pointer.rotation = previousRotate;\n          graphic.updateProps(pointer, {\n            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(newIdx, pointer);\n        }\n        if (showProgress) {\n          var previousProgress = oldProgressData[oldIdx];\n          var previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;\n          var progress = createProgress(newIdx, previousEndAngle);\n          var isClip = progressModel.get('clip');\n          graphic.updateProps(progress, {\n            shape: {\n              endAngle: linearMap(val, valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress); // Add data index and series index for indexing the data by element\n          // Useful in tooltip\n\n          setCommonECData(seriesModel.seriesIndex, data.dataType, newIdx, progress);\n          progressList[newIdx] = progress;\n        }\n      }).execute();\n      data.each(function (idx) {\n        var itemModel = data.getItemModel(idx);\n        var emphasisModel = itemModel.getModel('emphasis');\n        var focus = emphasisModel.get('focus');\n        var blurScope = emphasisModel.get('blurScope');\n        var emphasisDisabled = emphasisModel.get('disabled');\n        if (showPointer) {\n          var pointer = data.getItemGraphicEl(idx);\n          var symbolStyle = data.getItemVisual(idx, 'style');\n          var visualColor = symbolStyle.fill;\n          if (pointer instanceof ZRImage) {\n            var pathStyle = pointer.style;\n            pointer.useStyle(extend({\n              image: pathStyle.image,\n              x: pathStyle.x,\n              y: pathStyle.y,\n              width: pathStyle.width,\n              height: pathStyle.height\n            }, symbolStyle));\n          } else {\n            pointer.useStyle(symbolStyle);\n            pointer.type !== 'pointer' && pointer.setColor(visualColor);\n          }\n          pointer.setStyle(itemModel.getModel(['pointer', 'itemStyle']).getItemStyle());\n          if (pointer.style.fill === 'auto') {\n            pointer.setStyle('fill', getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));\n          }\n          pointer.z2EmphasisLift = 0;\n          setStatesStylesFromModel(pointer, itemModel);\n          toggleHoverEmphasis(pointer, focus, blurScope, emphasisDisabled);\n        }\n        if (showProgress) {\n          var progress = progressList[idx];\n          progress.useStyle(data.getItemVisual(idx, 'style'));\n          progress.setStyle(itemModel.getModel(['progress', 'itemStyle']).getItemStyle());\n          progress.z2EmphasisLift = 0;\n          setStatesStylesFromModel(progress, itemModel);\n          toggleHoverEmphasis(progress, focus, blurScope, emphasisDisabled);\n        }\n      });\n      this._progressEls = progressList;\n    }\n  };\n  GaugeView.prototype._renderAnchor = function (seriesModel, posInfo) {\n    var anchorModel = seriesModel.getModel('anchor');\n    var showAnchor = anchorModel.get('show');\n    if (showAnchor) {\n      var anchorSize = anchorModel.get('size');\n      var anchorType = anchorModel.get('icon');\n      var offsetCenter = anchorModel.get('offsetCenter');\n      var anchorKeepAspect = anchorModel.get('keepAspect');\n      var anchor = createSymbol(anchorType, posInfo.cx - anchorSize / 2 + parsePercent(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);\n      anchor.z2 = anchorModel.get('showAbove') ? 1 : 0;\n      anchor.setStyle(anchorModel.getModel('itemStyle').getItemStyle());\n      this.group.add(anchor);\n    }\n  };\n  GaugeView.prototype._renderTitleAndDetail = function (seriesModel, ecModel, api, getColor, posInfo) {\n    var _this = this;\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var contentGroup = new graphic.Group();\n    var newTitleEls = [];\n    var newDetailEls = [];\n    var hasAnimation = seriesModel.isAnimationEnabled();\n    var showPointerAbove = seriesModel.get(['pointer', 'showAbove']);\n    data.diff(this._data).add(function (idx) {\n      newTitleEls[idx] = new graphic.Text({\n        silent: true\n      });\n      newDetailEls[idx] = new graphic.Text({\n        silent: true\n      });\n    }).update(function (idx, oldIdx) {\n      newTitleEls[idx] = _this._titleEls[oldIdx];\n      newDetailEls[idx] = _this._detailEls[oldIdx];\n    }).execute();\n    data.each(function (idx) {\n      var itemModel = data.getItemModel(idx);\n      var value = data.get(valueDim, idx);\n      var itemGroup = new graphic.Group();\n      var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n      var itemTitleModel = itemModel.getModel('title');\n      if (itemTitleModel.get('show')) {\n        var titleOffsetCenter = itemTitleModel.get('offsetCenter');\n        var titleX = posInfo.cx + parsePercent(titleOffsetCenter[0], posInfo.r);\n        var titleY = posInfo.cy + parsePercent(titleOffsetCenter[1], posInfo.r);\n        var labelEl = newTitleEls[idx];\n        labelEl.attr({\n          z2: showPointerAbove ? 0 : 2,\n          style: createTextStyle(itemTitleModel, {\n            x: titleX,\n            y: titleY,\n            text: data.getName(idx),\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: autoColor\n          })\n        });\n        itemGroup.add(labelEl);\n      }\n      var itemDetailModel = itemModel.getModel('detail');\n      if (itemDetailModel.get('show')) {\n        var detailOffsetCenter = itemDetailModel.get('offsetCenter');\n        var detailX = posInfo.cx + parsePercent(detailOffsetCenter[0], posInfo.r);\n        var detailY = posInfo.cy + parsePercent(detailOffsetCenter[1], posInfo.r);\n        var width = parsePercent(itemDetailModel.get('width'), posInfo.r);\n        var height = parsePercent(itemDetailModel.get('height'), posInfo.r);\n        var detailColor = seriesModel.get(['progress', 'show']) ? data.getItemVisual(idx, 'style').fill : autoColor;\n        var labelEl = newDetailEls[idx];\n        var formatter_1 = itemDetailModel.get('formatter');\n        labelEl.attr({\n          z2: showPointerAbove ? 0 : 2,\n          style: createTextStyle(itemDetailModel, {\n            x: detailX,\n            y: detailY,\n            text: formatLabel(value, formatter_1),\n            width: isNaN(width) ? null : width,\n            height: isNaN(height) ? null : height,\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: detailColor\n          })\n        });\n        setLabelValueAnimation(labelEl, {\n          normal: itemDetailModel\n        }, value, function (value) {\n          return formatLabel(value, formatter_1);\n        });\n        hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel, {\n          getFormattedLabel: function (labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {\n            return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter_1);\n          }\n        });\n        itemGroup.add(labelEl);\n      }\n      contentGroup.add(itemGroup);\n    });\n    this.group.add(contentGroup);\n    this._titleEls = newTitleEls;\n    this._detailEls = newDetailEls;\n  };\n  GaugeView.type = 'gauge';\n  return GaugeView;\n}(ChartView);\nexport default GaugeView;","map":{"version":3,"names":["__extends","PointerPath","graphic","setStatesStylesFromModel","toggleHoverEmphasis","createTextStyle","setLabelValueAnimation","animateLabelValue","ChartView","parsePercent","round","linearMap","Sausage","createSymbol","ZRImage","extend","isFunction","isString","setCommonECData","parsePosition","seriesModel","api","center","get","width","getWidth","height","getHeight","size","Math","min","cx","cy","r","formatLabel","value","labelFormatter","label","replace","PI2","PI","GaugeView","_super","_this","apply","arguments","type","prototype","render","ecModel","group","removeAll","colorList","posInfo","_renderMain","_data","getData","dispose","clockwise","startAngle","endAngle","axisLineModel","getModel","roundCap","MainPath","Sector","showAxis","lineStyleModel","axisLineWidth","angleRangeSpan","prevEndAngle","i","length","percent","max","sector","shape","r0","silent","setStyle","fill","getLineStyle","add","getColor","tmp","_renderTicks","_renderTitleAndDetail","_renderAnchor","_renderPointer","minVal","maxVal","splitLineModel","tickModel","labelModel","splitNumber","subSplitNumber","splitLineLen","tickLen","angle","step","subStep","splitLineStyle","tickLineStyle","splitLineDistance","unitX","unitY","cos","sin","distance","splitLine","Line","x1","y1","x2","y2","style","stroke","autoColor","Text","text","x","y","verticalAlign","align","inheritColor","j","tickLine","oldData","oldProgressData","_progressEls","progressList","showPointer","progressModel","showProgress","data","valueDim","mapDimension","valueExtent","angleExtent","createPointer","idx","itemModel","getItemModel","pointerModel","pointerWidth","pointerLength","pointerStr","pointerOffset","pointerOffsetX","pointerOffsetY","pointerKeepAspect","pointer","rotation","createProgress","ProgressPath","isOverlap","progressWidth","count","progress","z2","diff","val","initProps","isNaN","setItemGraphicEl","isClip","seriesIndex","dataType","update","newIdx","oldIdx","previousPointer","getItemGraphicEl","previousRotate","updateProps","previousProgress","previousEndAngle","execute","each","emphasisModel","focus","blurScope","emphasisDisabled","symbolStyle","getItemVisual","visualColor","pathStyle","useStyle","image","setColor","getItemStyle","z2EmphasisLift","anchorModel","showAnchor","anchorSize","anchorType","offsetCenter","anchorKeepAspect","anchor","contentGroup","Group","newTitleEls","newDetailEls","hasAnimation","isAnimationEnabled","showPointerAbove","_titleEls","_detailEls","itemGroup","itemTitleModel","titleOffsetCenter","titleX","titleY","labelEl","attr","getName","itemDetailModel","detailOffsetCenter","detailX","detailY","detailColor","formatter_1","normal","getFormattedLabel","labelDataIndex","status","labelDimIndex","fmt","extendParams","interpolatedValue"],"sources":["D:/codes/SpringBoot/demo/node_modules/echarts/lib/chart/gauge/GaugeView.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport PointerPath from './PointerPath.js';\nimport * as graphic from '../../util/graphic.js';\nimport { setStatesStylesFromModel, toggleHoverEmphasis } from '../../util/states.js';\nimport { createTextStyle, setLabelValueAnimation, animateLabelValue } from '../../label/labelStyle.js';\nimport ChartView from '../../view/Chart.js';\nimport { parsePercent, round, linearMap } from '../../util/number.js';\nimport Sausage from '../../util/shape/sausage.js';\nimport { createSymbol } from '../../util/symbol.js';\nimport ZRImage from 'zrender/lib/graphic/Image.js';\nimport { extend, isFunction, isString } from 'zrender/lib/core/util.js';\nimport { setCommonECData } from '../../util/innerStore.js';\n\nfunction parsePosition(seriesModel, api) {\n  var center = seriesModel.get('center');\n  var width = api.getWidth();\n  var height = api.getHeight();\n  var size = Math.min(width, height);\n  var cx = parsePercent(center[0], api.getWidth());\n  var cy = parsePercent(center[1], api.getHeight());\n  var r = parsePercent(seriesModel.get('radius'), size / 2);\n  return {\n    cx: cx,\n    cy: cy,\n    r: r\n  };\n}\n\nfunction formatLabel(value, labelFormatter) {\n  var label = value == null ? '' : value + '';\n\n  if (labelFormatter) {\n    if (isString(labelFormatter)) {\n      label = labelFormatter.replace('{value}', label);\n    } else if (isFunction(labelFormatter)) {\n      label = labelFormatter(value);\n    }\n  }\n\n  return label;\n}\n\nvar PI2 = Math.PI * 2;\n\nvar GaugeView =\n/** @class */\nfunction (_super) {\n  __extends(GaugeView, _super);\n\n  function GaugeView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = GaugeView.type;\n    return _this;\n  }\n\n  GaugeView.prototype.render = function (seriesModel, ecModel, api) {\n    this.group.removeAll();\n    var colorList = seriesModel.get(['axisLine', 'lineStyle', 'color']);\n    var posInfo = parsePosition(seriesModel, api);\n\n    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);\n\n    this._data = seriesModel.getData();\n  };\n\n  GaugeView.prototype.dispose = function () {};\n\n  GaugeView.prototype._renderMain = function (seriesModel, ecModel, api, colorList, posInfo) {\n    var group = this.group;\n    var clockwise = seriesModel.get('clockwise');\n    var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n    var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n    var axisLineModel = seriesModel.getModel('axisLine');\n    var roundCap = axisLineModel.get('roundCap');\n    var MainPath = roundCap ? Sausage : graphic.Sector;\n    var showAxis = axisLineModel.get('show');\n    var lineStyleModel = axisLineModel.getModel('lineStyle');\n    var axisLineWidth = lineStyleModel.get('width');\n    var angleRangeSpan = !((endAngle - startAngle) % PI2) && endAngle !== startAngle ? PI2 : (endAngle - startAngle) % PI2;\n    var prevEndAngle = startAngle;\n\n    for (var i = 0; showAxis && i < colorList.length; i++) {\n      // Clamp\n      var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n      endAngle = startAngle + angleRangeSpan * percent;\n      var sector = new MainPath({\n        shape: {\n          startAngle: prevEndAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: posInfo.r - axisLineWidth,\n          r: posInfo.r\n        },\n        silent: true\n      });\n      sector.setStyle({\n        fill: colorList[i][1]\n      });\n      sector.setStyle(lineStyleModel.getLineStyle( // Because we use sector to simulate arc\n      // so the properties for stroking are useless\n      ['color', 'width']));\n      group.add(sector);\n      prevEndAngle = endAngle;\n    }\n\n    var getColor = function (percent) {\n      // Less than 0\n      if (percent <= 0) {\n        return colorList[0][1];\n      }\n\n      var i;\n\n      for (i = 0; i < colorList.length; i++) {\n        if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {\n          return colorList[i][1];\n        }\n      } // More than 1\n\n\n      return colorList[i - 1][1];\n    };\n\n    if (!clockwise) {\n      var tmp = startAngle;\n      startAngle = endAngle;\n      endAngle = tmp;\n    }\n\n    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n\n    this._renderTitleAndDetail(seriesModel, ecModel, api, getColor, posInfo);\n\n    this._renderAnchor(seriesModel, posInfo);\n\n    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n  };\n\n  GaugeView.prototype._renderTicks = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var cx = posInfo.cx;\n    var cy = posInfo.cy;\n    var r = posInfo.r;\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var splitLineModel = seriesModel.getModel('splitLine');\n    var tickModel = seriesModel.getModel('axisTick');\n    var labelModel = seriesModel.getModel('axisLabel');\n    var splitNumber = seriesModel.get('splitNumber');\n    var subSplitNumber = tickModel.get('splitNumber');\n    var splitLineLen = parsePercent(splitLineModel.get('length'), r);\n    var tickLen = parsePercent(tickModel.get('length'), r);\n    var angle = startAngle;\n    var step = (endAngle - startAngle) / splitNumber;\n    var subStep = step / subSplitNumber;\n    var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n    var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n    var splitLineDistance = splitLineModel.get('distance');\n    var unitX;\n    var unitY;\n\n    for (var i = 0; i <= splitNumber; i++) {\n      unitX = Math.cos(angle);\n      unitY = Math.sin(angle); // Split line\n\n      if (splitLineModel.get('show')) {\n        var distance = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;\n        var splitLine = new graphic.Line({\n          shape: {\n            x1: unitX * (r - distance) + cx,\n            y1: unitY * (r - distance) + cy,\n            x2: unitX * (r - splitLineLen - distance) + cx,\n            y2: unitY * (r - splitLineLen - distance) + cy\n          },\n          style: splitLineStyle,\n          silent: true\n        });\n\n        if (splitLineStyle.stroke === 'auto') {\n          splitLine.setStyle({\n            stroke: getColor(i / splitNumber)\n          });\n        }\n\n        group.add(splitLine);\n      } // Label\n\n\n      if (labelModel.get('show')) {\n        var distance = labelModel.get('distance') + splitLineDistance;\n        var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));\n        var autoColor = getColor(i / splitNumber);\n        group.add(new graphic.Text({\n          style: createTextStyle(labelModel, {\n            text: label,\n            x: unitX * (r - splitLineLen - distance) + cx,\n            y: unitY * (r - splitLineLen - distance) + cy,\n            verticalAlign: unitY < -0.8 ? 'top' : unitY > 0.8 ? 'bottom' : 'middle',\n            align: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'\n          }, {\n            inheritColor: autoColor\n          }),\n          silent: true\n        }));\n      } // Axis tick\n\n\n      if (tickModel.get('show') && i !== splitNumber) {\n        var distance = tickModel.get('distance');\n        distance = distance ? distance + axisLineWidth : axisLineWidth;\n\n        for (var j = 0; j <= subSplitNumber; j++) {\n          unitX = Math.cos(angle);\n          unitY = Math.sin(angle);\n          var tickLine = new graphic.Line({\n            shape: {\n              x1: unitX * (r - distance) + cx,\n              y1: unitY * (r - distance) + cy,\n              x2: unitX * (r - tickLen - distance) + cx,\n              y2: unitY * (r - tickLen - distance) + cy\n            },\n            silent: true,\n            style: tickLineStyle\n          });\n\n          if (tickLineStyle.stroke === 'auto') {\n            tickLine.setStyle({\n              stroke: getColor((i + j / subSplitNumber) / splitNumber)\n            });\n          }\n\n          group.add(tickLine);\n          angle += subStep;\n        }\n\n        angle -= subStep;\n      } else {\n        angle += step;\n      }\n    }\n  };\n\n  GaugeView.prototype._renderPointer = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var oldData = this._data;\n    var oldProgressData = this._progressEls;\n    var progressList = [];\n    var showPointer = seriesModel.get(['pointer', 'show']);\n    var progressModel = seriesModel.getModel('progress');\n    var showProgress = progressModel.get('show');\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var valueExtent = [minVal, maxVal];\n    var angleExtent = [startAngle, endAngle];\n\n    function createPointer(idx, angle) {\n      var itemModel = data.getItemModel(idx);\n      var pointerModel = itemModel.getModel('pointer');\n      var pointerWidth = parsePercent(pointerModel.get('width'), posInfo.r);\n      var pointerLength = parsePercent(pointerModel.get('length'), posInfo.r);\n      var pointerStr = seriesModel.get(['pointer', 'icon']);\n      var pointerOffset = pointerModel.get('offsetCenter');\n      var pointerOffsetX = parsePercent(pointerOffset[0], posInfo.r);\n      var pointerOffsetY = parsePercent(pointerOffset[1], posInfo.r);\n      var pointerKeepAspect = pointerModel.get('keepAspect');\n      var pointer; // not exist icon type will be set 'rect'\n\n      if (pointerStr) {\n        pointer = createSymbol(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);\n      } else {\n        pointer = new PointerPath({\n          shape: {\n            angle: -Math.PI / 2,\n            width: pointerWidth,\n            r: pointerLength,\n            x: pointerOffsetX,\n            y: pointerOffsetY\n          }\n        });\n      }\n\n      pointer.rotation = -(angle + Math.PI / 2);\n      pointer.x = posInfo.cx;\n      pointer.y = posInfo.cy;\n      return pointer;\n    }\n\n    function createProgress(idx, endAngle) {\n      var roundCap = progressModel.get('roundCap');\n      var ProgressPath = roundCap ? Sausage : graphic.Sector;\n      var isOverlap = progressModel.get('overlap');\n      var progressWidth = isOverlap ? progressModel.get('width') : axisLineWidth / data.count();\n      var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;\n      var r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;\n      var progress = new ProgressPath({\n        shape: {\n          startAngle: startAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: r0,\n          r: r\n        }\n      });\n      isOverlap && (progress.z2 = maxVal - data.get(valueDim, idx) % maxVal);\n      return progress;\n    }\n\n    if (showProgress || showPointer) {\n      data.diff(oldData).add(function (idx) {\n        var val = data.get(valueDim, idx);\n\n        if (showPointer) {\n          var pointer = createPointer(idx, startAngle); // TODO hide pointer on NaN value?\n\n          graphic.initProps(pointer, {\n            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(idx, pointer);\n        }\n\n        if (showProgress) {\n          var progress = createProgress(idx, startAngle);\n          var isClip = progressModel.get('clip');\n          graphic.initProps(progress, {\n            shape: {\n              endAngle: linearMap(val, valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress); // Add data index and series index for indexing the data by element\n          // Useful in tooltip\n\n          setCommonECData(seriesModel.seriesIndex, data.dataType, idx, progress);\n          progressList[idx] = progress;\n        }\n      }).update(function (newIdx, oldIdx) {\n        var val = data.get(valueDim, newIdx);\n\n        if (showPointer) {\n          var previousPointer = oldData.getItemGraphicEl(oldIdx);\n          var previousRotate = previousPointer ? previousPointer.rotation : startAngle;\n          var pointer = createPointer(newIdx, previousRotate);\n          pointer.rotation = previousRotate;\n          graphic.updateProps(pointer, {\n            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(newIdx, pointer);\n        }\n\n        if (showProgress) {\n          var previousProgress = oldProgressData[oldIdx];\n          var previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;\n          var progress = createProgress(newIdx, previousEndAngle);\n          var isClip = progressModel.get('clip');\n          graphic.updateProps(progress, {\n            shape: {\n              endAngle: linearMap(val, valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress); // Add data index and series index for indexing the data by element\n          // Useful in tooltip\n\n          setCommonECData(seriesModel.seriesIndex, data.dataType, newIdx, progress);\n          progressList[newIdx] = progress;\n        }\n      }).execute();\n      data.each(function (idx) {\n        var itemModel = data.getItemModel(idx);\n        var emphasisModel = itemModel.getModel('emphasis');\n        var focus = emphasisModel.get('focus');\n        var blurScope = emphasisModel.get('blurScope');\n        var emphasisDisabled = emphasisModel.get('disabled');\n\n        if (showPointer) {\n          var pointer = data.getItemGraphicEl(idx);\n          var symbolStyle = data.getItemVisual(idx, 'style');\n          var visualColor = symbolStyle.fill;\n\n          if (pointer instanceof ZRImage) {\n            var pathStyle = pointer.style;\n            pointer.useStyle(extend({\n              image: pathStyle.image,\n              x: pathStyle.x,\n              y: pathStyle.y,\n              width: pathStyle.width,\n              height: pathStyle.height\n            }, symbolStyle));\n          } else {\n            pointer.useStyle(symbolStyle);\n            pointer.type !== 'pointer' && pointer.setColor(visualColor);\n          }\n\n          pointer.setStyle(itemModel.getModel(['pointer', 'itemStyle']).getItemStyle());\n\n          if (pointer.style.fill === 'auto') {\n            pointer.setStyle('fill', getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));\n          }\n\n          pointer.z2EmphasisLift = 0;\n          setStatesStylesFromModel(pointer, itemModel);\n          toggleHoverEmphasis(pointer, focus, blurScope, emphasisDisabled);\n        }\n\n        if (showProgress) {\n          var progress = progressList[idx];\n          progress.useStyle(data.getItemVisual(idx, 'style'));\n          progress.setStyle(itemModel.getModel(['progress', 'itemStyle']).getItemStyle());\n          progress.z2EmphasisLift = 0;\n          setStatesStylesFromModel(progress, itemModel);\n          toggleHoverEmphasis(progress, focus, blurScope, emphasisDisabled);\n        }\n      });\n      this._progressEls = progressList;\n    }\n  };\n\n  GaugeView.prototype._renderAnchor = function (seriesModel, posInfo) {\n    var anchorModel = seriesModel.getModel('anchor');\n    var showAnchor = anchorModel.get('show');\n\n    if (showAnchor) {\n      var anchorSize = anchorModel.get('size');\n      var anchorType = anchorModel.get('icon');\n      var offsetCenter = anchorModel.get('offsetCenter');\n      var anchorKeepAspect = anchorModel.get('keepAspect');\n      var anchor = createSymbol(anchorType, posInfo.cx - anchorSize / 2 + parsePercent(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);\n      anchor.z2 = anchorModel.get('showAbove') ? 1 : 0;\n      anchor.setStyle(anchorModel.getModel('itemStyle').getItemStyle());\n      this.group.add(anchor);\n    }\n  };\n\n  GaugeView.prototype._renderTitleAndDetail = function (seriesModel, ecModel, api, getColor, posInfo) {\n    var _this = this;\n\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var contentGroup = new graphic.Group();\n    var newTitleEls = [];\n    var newDetailEls = [];\n    var hasAnimation = seriesModel.isAnimationEnabled();\n    var showPointerAbove = seriesModel.get(['pointer', 'showAbove']);\n    data.diff(this._data).add(function (idx) {\n      newTitleEls[idx] = new graphic.Text({\n        silent: true\n      });\n      newDetailEls[idx] = new graphic.Text({\n        silent: true\n      });\n    }).update(function (idx, oldIdx) {\n      newTitleEls[idx] = _this._titleEls[oldIdx];\n      newDetailEls[idx] = _this._detailEls[oldIdx];\n    }).execute();\n    data.each(function (idx) {\n      var itemModel = data.getItemModel(idx);\n      var value = data.get(valueDim, idx);\n      var itemGroup = new graphic.Group();\n      var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n      var itemTitleModel = itemModel.getModel('title');\n\n      if (itemTitleModel.get('show')) {\n        var titleOffsetCenter = itemTitleModel.get('offsetCenter');\n        var titleX = posInfo.cx + parsePercent(titleOffsetCenter[0], posInfo.r);\n        var titleY = posInfo.cy + parsePercent(titleOffsetCenter[1], posInfo.r);\n        var labelEl = newTitleEls[idx];\n        labelEl.attr({\n          z2: showPointerAbove ? 0 : 2,\n          style: createTextStyle(itemTitleModel, {\n            x: titleX,\n            y: titleY,\n            text: data.getName(idx),\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: autoColor\n          })\n        });\n        itemGroup.add(labelEl);\n      }\n\n      var itemDetailModel = itemModel.getModel('detail');\n\n      if (itemDetailModel.get('show')) {\n        var detailOffsetCenter = itemDetailModel.get('offsetCenter');\n        var detailX = posInfo.cx + parsePercent(detailOffsetCenter[0], posInfo.r);\n        var detailY = posInfo.cy + parsePercent(detailOffsetCenter[1], posInfo.r);\n        var width = parsePercent(itemDetailModel.get('width'), posInfo.r);\n        var height = parsePercent(itemDetailModel.get('height'), posInfo.r);\n        var detailColor = seriesModel.get(['progress', 'show']) ? data.getItemVisual(idx, 'style').fill : autoColor;\n        var labelEl = newDetailEls[idx];\n        var formatter_1 = itemDetailModel.get('formatter');\n        labelEl.attr({\n          z2: showPointerAbove ? 0 : 2,\n          style: createTextStyle(itemDetailModel, {\n            x: detailX,\n            y: detailY,\n            text: formatLabel(value, formatter_1),\n            width: isNaN(width) ? null : width,\n            height: isNaN(height) ? null : height,\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: detailColor\n          })\n        });\n        setLabelValueAnimation(labelEl, {\n          normal: itemDetailModel\n        }, value, function (value) {\n          return formatLabel(value, formatter_1);\n        });\n        hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel, {\n          getFormattedLabel: function (labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {\n            return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter_1);\n          }\n        });\n        itemGroup.add(labelEl);\n      }\n\n      contentGroup.add(itemGroup);\n    });\n    this.group.add(contentGroup);\n    this._titleEls = newTitleEls;\n    this._detailEls = newDetailEls;\n  };\n\n  GaugeView.type = 'gauge';\n  return GaugeView;\n}(ChartView);\n\nexport default GaugeView;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}